<!DOCTYPE html>
<html>
    <head>
        <link href="/ETL-Yertl/theme/css/normalize.css" rel="stylesheet">
        <link href="/ETL-Yertl/theme/css/skeleton.css" rel="stylesheet">
        <link href="/ETL-Yertl/theme/css/statocles-default.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
        <title>Yertl</title>
        <meta content="Statocles 0.055" name="generator">
        
    </head>
    <body>
        <header>
            <nav class="navbar">
                <div class="container">
                    <a class="brand" href="/ETL-Yertl/">Yertl</a>
                    <ul>
                        <li>
                            <a href="/ETL-Yertl/blog">Blog</a>
                        </li>
                        <li>
                            <a href="/ETL-Yertl/pod">Docs</a>
                        </li>
                        <li>
                            <a href="http://github.com/preaction/ETL-Yertl">Code</a>
                        </li>
                        <li>
                            <a href="http://github.com/preaction/ETL-Yertl/issues">Bugs</a>
                        </li>
                        <li>
                            <a href="http://metacpan.org/pod/ETL::Yertl">CPAN</a>
                        </li>
                        <li>
                            <a href="https://chat.mibbit.com/?channel=%23yertl&amp;server=irc.perl.org">IRC</a>
                        </li>
                    </ul>
                    
                </div>
            </nav>
            
        </header>
        <div class="main container">
            <a class="button" href="/ETL-Yertl/pod/ETL/Yertl/Command/yq.html">
    Back to documentation
</a>
<pre>package ETL::Yertl::Command::yq;
# ABSTRACT: Filter and construct documents using a mini-language

use ETL::Yertl;
use ETL::Yertl::Format::yaml;
use boolean qw( :all );
use Module::Runtime qw( use_module );
our $VERBOSE = $ENV{YERTL_VERBOSE} // 0;

sub is_empty {
    return ref $_[0] eq &#39;empty&#39;;
}

sub main {
    my $class = shift;

    my %opt;
    if ( ref $_[-1] eq &#39;HASH&#39; ) {
        %opt = %{ pop @_ };
    }

    my ( $filter, @files ) = @_;

    die &quot;Must give a filter\n&quot; unless $filter;

    push @files, &quot;-&quot; unless @files;
    for my $file ( @files ) {
        # We&#39;re doing a similar behavior to &lt;&gt;, but manually for easier testing.
        my $fh;
        if ( $file eq &#39;-&#39; ) {
            # Use the existing STDIN so tests can fake it
            $fh = \*STDIN;
        }
        else {
            unless ( open $fh, &#39;&lt;&#39;, $file ) {
                warn &quot;Could not open file &#39;$file&#39; for reading: $!\n&quot;;
                next;
            }
        }

        my $in_fmt = ETL::Yertl::Format::yaml-&gt;new( input =&gt; $fh );
        my $scope = {};
        for my $doc ( $in_fmt-&gt;read ) {
            my @output = $class-&gt;filter( $filter, $doc, $scope );
            $class-&gt;write( \@output, \%opt );
        }

        # Finish the scope, cleaning up any collections
        $class-&gt;write( [ $class-&gt;finish( $scope ) ], \%opt );
    }
}

sub write {
    my ( $class, $docs, $opt ) = @_;

    if ( $opt-&gt;{xargs} ) {
        print &quot;$_\n&quot; for @$docs;
        return;
    }

    my $out_fmt = ETL::Yertl::Format::yaml-&gt;new;
    for my $doc ( @$docs ) {
        next if is_empty( $doc );
        if ( isTrue( $doc ) ) {
            print $out_fmt-&gt;write( &quot;true&quot; );
        }
        elsif ( isFalse( $doc ) ) {
            print $out_fmt-&gt;write( &quot;false&quot; );
        }
        else {
            print $out_fmt-&gt;write( $doc );
        }
    }
}

$ENV{YQ_CLASS} ||= &#39;ETL::Yertl::Command::yq::Regex&#39;;
use_module( $ENV{YQ_CLASS} );
{
    no strict &#39;refs&#39;;
    no warnings &#39;once&#39;;
    *filter = *{ $ENV{YQ_CLASS} . &quot;::filter&quot; };
}

sub finish {
    my ( $class, $scope ) = @_;
    if ( $scope-&gt;{sort} ) {
        return map { $_-&gt;[1] } sort { $a-&gt;[0] cmp $b-&gt;[0] } @{ $scope-&gt;{sort} };
    }
    elsif ( $scope-&gt;{group_by} ) {
        return $scope-&gt;{group_by};
    }
    return;
}

1;
__END__

=head1 SYNOPSIS

    ### On a shell...
    $ yq [-v] &lt;script&gt; [&lt;file&gt;...]
    $ yq [-h|--help|--version]

    ### In Perl...
    use ETL::Yertl;
    yq( &#39;&lt;script&gt;&#39;, &#39;&lt;filename&gt;&#39;, { verbose =&gt; 1 } );

=head1 DESCRIPTION

=head1 ARGUMENTS

=head1 OPTIONS

</pre>

        </div>
        <footer>
            <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61295159-4', 'auto');
  ga('send', 'pageview');

</script>

            <div class="container tagline">
                <a href="http://preaction.github.io/Statocles">Made with Statocles</a><br>
                <a href="http://www.perl.org">Powered by Perl</a>
            </div>
        </footer>
    </body>
</html>
