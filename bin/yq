#!/usr/bin/env perl
package yq;
# ABSTRACT: Filter YAML through a command-line program

use App::YAML::Filter::Base;
use Pod::Usage qw( pod2usage );
use Getopt::Long qw( GetOptionsFromArray );
use YAML;

sub empty() {
    bless {}, 'empty';
}
sub is_empty {
    return ref $_[0] eq 'empty';
}

sub main {
    my ( $class, @argv ) = @_;
    my %opt;
    GetOptionsFromArray( \@argv, \%opt,
        'help|h',
    );
    pod2usage(0) if $opt{help};

    my $filter = shift @argv;
    pod2usage("ERROR: Must give a filter") unless $filter;

    push @argv, "-" unless @argv;
    for $ARGV ( @argv ) {
        # We're doing a similar behavior to <>, but manually for easier testing.
        my $fh;
        if ( $ARGV eq '-' ) {
            # Use the existing STDIN so tests can fake it
            $fh = \*STDIN;
        }
        else {
            unless ( open $fh, '<', $ARGV ) {
                warn "Could not open file '$ARGV' for reading: $!\n";
                next;
            }
        }

        my $buffer;
        while ( my $line = <$fh> ) {
            # --- is the start of a new document
            if ( $buffer && $line =~ /^---/ ) {
                # Flush the previous document
                my @output = $class->filter( $filter, YAML::Load( $buffer ) );
                print YAML::Dump( $_ ) for grep { !is_empty( $_ ) } @output;
                $buffer = '';
            }
            $buffer .= $line;
        }
        # Flush the buffer in the case of a single document with no ---
        if ( $buffer =~ /\S/ ) {
            #print STDERR "Buffer is: $buffer\n";
            my @output = $class->filter( $filter, YAML::Load( $buffer ) );
            print YAML::Dump( $_ ) for grep { !is_empty( $_ ) } @output;
        }
    }

    return 0;
}

# Filter MUST NOT mutate $doc!
sub filter {
    my ( $class, $filter, $doc ) = @_;
    # , does multiple filters, yielding multiple documents
    if ( $filter =~ /,/ ) {
        my @filters = split /\s*,\s*/, $filter;
        return map { $class->filter( $_, $doc ) } @filters;
    }
    # Whole document (needed for if/then)
    elsif ( $filter =~ /^[.]$/ ) {
        return $doc;
    }
    # Hash and array keys to traverse the data structure
    elsif ( $filter =~ /^((?:[.](?:\w+|\[\d*\]))+)$/ ) {
        my @keys = split /[.]/, $1;
        my $subdoc = $doc;
        for my $key ( @keys[1..$#keys] ) {
            if ( $key =~ /^\[\]$/ ) {
                return @{ $subdoc };
            }
            elsif ( $key =~ /^\[(\d+)\]$/ ) {
                $subdoc = $subdoc->[ $1 ];
            }
            elsif ( $key =~ /^\w+$/ ) {
                $subdoc = $subdoc->{ $key };
            }
            else {
                die "Invalid filter key '$key'";
            }
        }
        return $subdoc;
    }
    # If/then (future: else, better conditions)
    elsif ( $filter =~ /^if\s+(.+?)\s+(eq|ne)\s+(.+?)\s+then\s+(.+?)(?:\s+else\s+(.+?))?$/ ) {
        my ( $lhs_filter, $cond, $rhs_filter, $true_filter, $false_filter ) = ( $1, $2, $3, $4, $5 );
        my $lhs_value = $class->filter( $lhs_filter, $doc );
        my $rhs_value = $class->filter( $rhs_filter, $doc );
        if ( $cond eq 'eq' ) {
            if ( defined $lhs_value == defined $rhs_value && $lhs_value eq $rhs_value ) {
                return $class->filter( $true_filter, $doc );
            }
            elsif ( $false_filter ) {
                return $class->filter( $false_filter, $doc );
            }
            else {
                return;
            }
        }
        elsif ( $cond eq 'ne' ) {
            if ( $lhs_value ne $rhs_value ) {
                return $class->filter( $true_filter, $doc );
            }
            elsif ( $false_filter ) {
                return $class->filter( $false_filter, $doc );
            }
            else {
                return;
            }
        }
    }
    elsif ( $filter eq 'empty' ) {
        return empty;
    }
    # Barewords (future: quoted strings)
    elsif ( $filter !~ /^[.]/ ) {
        return $filter;
    }
    else {
        die "Could not parse filter '$filter'\n";
    }
    return;
}

exit __PACKAGE__->main( @ARGV ) unless caller(0);

=head1 SYNOPSIS

    yq <filter> [<file>...]

    yq -h|--help

=head1 DESCRIPTION

This program takes a stream of YAML documents (on STDIN or file arguments),
applies a filter, then writes the results to STDOUT.

=head1 ARGUMENTS

=head2 filter

The filter to run. For the filter syntax, see L<SYNTAX>.

=head2 <file>

A YAML file to filter. The special file "-" refers to STDIN. If no files are
specified, filter STDIN.

=head1 OPTIONS

=head2 -h | --help

Show this help document.

=head1 SYNTAX

=head2 FILTERS

Filters select a portion of the incoming documents. Filters can be combined
to reach deep inside the documents you're working with.

=over

=item .

Returns the entire document, unfiltered. Useful in if/then statements.

    # INPUT
    foo: bar
    baz: fuzz

    $ yq .
    foo: bar
    baz: fuzz

=item .key

Extract a single item out of a hash.

    # INPUT
    foo:
        bar: baz
        fizz: fuzz

    $ yq .foo
    bar: baz
    fizz: fuzz

    $ yq .foo.fizz
    fuzz

=item .[#]

Extract a single item out of an array.

    # INPUT
    - foo: fuzz
    - bar: buzz
    - baz:
        good: bad
        new: old

    $ yq .[1]
    bar: buzz

    $ yq .[2]
    baz:
        good: bad
        new: old

    $ yq .[2].baz
    good: bad
    new: old

    $ yq .[2].baz.new
    old

=item []

Use [] with no index to flatten an array.

    # INPUT
    - foo: fuzz
    - bar: buzz

    $ yq '.[]'
    foo: fuzz
    ---
    bar: buzz

=item ,

Multiple filters may be separated by commas to yield multiple documents in the
output.

    # INPUT
    foo: bar
    baz: fuzz

    $ yq '.foo, .baz'
    bar
    ---
    fuzz

=back

=head2 VALUES

=over

=item empty

The special value empty suppresses printing of a document. Normally,
an undefined document will show up in the output as "--- ~". If your
filter instead yields empty, the document will not be printed at all.

This is especially useful in conditionals:

    # INPUT
    foo: bar
    baz: fuzz

    $ yq 'if .foo eq bar then . else empty'
    foo: bar
    baz: fuzz

    $ yq 'if .foo eq buzz then . else empty'
    $

=item Values

Any bareword that is not recognized as a syntax element is treated
as a value.

=back

=head2 CONDITIONALS

=over

=item if lhs_filter eq rhs_filter then true_filter else false_filter

If the lhs filter and rhs_filter are equal, return the true_filter,
otherwise return the false_filter.

For example

    # INPUT
    foo: bar
    baz: fuzz

    $ yq 'if .foo eq bar then .baz else .foo'
    fuzz

    $ yq 'if .foo eq buzz then .baz else .foo'
    bar

The else false_filter is optional and defaults to returning undefined.

=back

=head1 SEE ALSO

=over

=item jq

L<http://stedolan.github.io/jq/> A filter for JSON documents. The inspiration
for this project.

=back
